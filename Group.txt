Project Report
Is1220_Group 24 Thomas Cocher & Sarah Gross

Introduction


1)	Presentation of the project
This project is about developing a Library Management System (LMS). We have to implement with OOP a fully-operational library, where 3 kinds of items are stored books, CDs and DVDs. One can register to the library and then be able to consult onsite or borrow those items, with rules which depend on the status of their membership.
The first part of this project, which you are currently consulting, only deals with the design and the implementation of the classes which will be needed for this library “the library core”; the methods which enable the user to use the library will come in the second part.

2)	Analysis and design
The user of the LMS ought to be able to use it without understanding how it works. Therefore, we decided to implement a Factory pattern for the manipulation of library items.
We were not sure if using a Factory was the right solution because the information to give at the creation depends on the item, for instance a book needs an ISVN number. Which means that the user has to know beforehand which information are needed for each item, which is in contradiction with the idea that the user does not know the details of the factory… We then thought about making an interface with the user when a user asks the creation of an item, the console asks him the information which lacks if he has not filled all the attributes. We would use a Scanner object in order to do this. After discussions with the PC teacher, it seemed simpler for the user just to enter an array of Strings containing all the attributes he wanted to fill, and if some attributes were missing the Factory would give the value NULL to those.

We also wondered about how to manage the update of the status of the loans and the fidelity cards. Since we needed to continuously make updates, we thought about using an observer pattern, but we eventually realized that it was not adapted to the situation because we had only one observer. Updating the cards every time the program was launched seemed a better solution. Thus, we created a Launcher class which implements all the actions we need when the Library is “opened” a new time
-	Creating a new Factory so that the user can create new items whenever he wants
-	Fetching from the database all the information about the Library
-	Updating all the expiration dates; for the fidelity cards or the loans.
We first made three functions for each kind of update, but since for each update we needed to make a loop on the list of the members, for speed considerations we decided to put all those updates in one same method, hence reducing the loops needed to one.
We realized that we needed a kind of database in order to keep all the information about our Library. In TPs, the examples were just to see if our code worked, we did not need our examples to remain once we had closed the program. However here it is different we have one single Library on which the users will work during several months so it is compulsory for the information to be accessible all this time and we have to be able to close the program without losing it!
The information needs therefore to be stored somewhere. Since we cannot have a kind of MySQL-like database with Java, we decided to use the InputOutput streams to store the composition of the Library and its members in text files. We decided to store the information about each member, and the information about the Library. The problem was then how to translate the idea of an object into a text file.

In order to see clearly what to do, we first drew on paper the UML diagram of the LMS we stated which classes we needed, what attributes that had, of what type. We chose to use some type which were not seen in class, for instance the ENUM type for the attributes which had only a couple of values possible (items bookCDDVD , fidelity card standard, frequent, gold) because this type was created for this kind of use.
Thinking about the classes we needed made us reflecting about how they would be used in the project and thus raised the questions above.
Then we could start to implement the project.

3)	Implementation
a)	Code structure
b)	Testing
We hesitated about first making the tests we needed, then programming the classes which would make those tests work, as in the xxxxxx implementation seen in classes. The advantage is that we can see how much work is left very easily that way. Nevertheless since the methods were supposed to be programmed on the second part we could not use this strategy.

4)	Results


Conclusion
